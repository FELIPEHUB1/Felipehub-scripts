local CK = loadstring(game:HttpGet("https://raw.githubusercontent.com/4lpaca-pin/CompKiller/refs/heads/main/src/source.luau"))()

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Teams = game:GetService("Teams")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = Workspace.CurrentCamera

local UI = CK.new({
    Name = "FELIPEHUB",
    Keybind = "LeftAlt",
    Scale = CK.Scale.Window
})

----------------- ABA ESP -----------------
local tabESP = UI:DrawTab({Name = "ESP", Icon = "star"})
local sectionESP = tabESP:DrawSection({Name = "ESP Menu", Position = "left"})

local espEnabled = false
local boxes = {}
local RainbowName = false
local RainbowHealth = false
local RainbowBox = false

local function getRainbowColor(speed)
    local time = tick() * speed
    local r = (math.sin(time) + 1) / 2
    local g = (math.sin(time + 2) + 1) / 2
    local b = (math.sin(time + 4) + 1) / 2
    return Color3.new(r, g, b)
end

local function healthColor(health, maxHealth)
    local ratio = math.clamp(health / maxHealth, 0, 1)
    return Color3.fromRGB(255 * (1 - ratio), 255 * ratio, 0)
end

local function createBox()
    local Drawing = Drawing
    local box = Drawing.new("Square")
    box.Thickness = 2
    box.Transparency = 1
    box.Filled = false

    local name = Drawing.new("Text")
    name.Size = 14
    name.Center = true
    name.Outline = true

    local healthText = Drawing.new("Text")
    healthText.Size = 14
    healthText.Center = true
    healthText.Outline = true

    local distanceText = Drawing.new("Text")
    distanceText.Size = 12
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.Color = Color3.fromRGB(200, 200, 200)

    return {
        box = box,
        name = name,
        healthText = healthText,
        distanceText = distanceText,
        blink = false,
        blinkTimer = 0
    }
end

local function removeBox(boxTable)
    if boxTable then
        if boxTable.box then boxTable.box:Remove() end
        if boxTable.name then boxTable.name:Remove() end
        if boxTable.healthText then boxTable.healthText:Remove() end
        if boxTable.distanceText then boxTable.distanceText:Remove() end
    end
end

local function updateBox(boxTable, character, deltaTime)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or humanoid.Health <= 0 or not rootPart then
        boxTable.box.Visible = false
        boxTable.name.Visible = false
        boxTable.healthText.Visible = false
        boxTable.distanceText.Visible = false
        return false
    end

    local pos, visible = Camera:WorldToViewportPoint(rootPart.Position)
    if not visible then
        boxTable.box.Visible = false
        boxTable.name.Visible = false
        boxTable.healthText.Visible = false
        boxTable.distanceText.Visible = false
        return true
    end

    local topPos, _ = Camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 3, 0))
    local bottomPos, _ = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0))

    local height = math.abs(topPos.Y - bottomPos.Y)
    local width = height / 2

    boxTable.box.Size = Vector2.new(width, height)
    boxTable.box.Position = Vector2.new(pos.X - width / 2, pos.Y - height / 2)

    local healthRatio = humanoid.Health / humanoid.MaxHealth
    local baseColor = healthColor(humanoid.Health, humanoid.MaxHealth)
    local color = baseColor

    if RainbowBox then
        color = getRainbowColor(3)
    end

    if healthRatio < 0.2 then
        boxTable.blinkTimer = boxTable.blinkTimer + deltaTime
        if boxTable.blinkTimer > 0.5 then
            boxTable.blink = not boxTable.blink
            boxTable.blinkTimer = 0
        end
        boxTable.box.Color = boxTable.blink and Color3.new(1,0,0) or color
    else
        boxTable.box.Color = color
        boxTable.blink = false
        boxTable.blinkTimer = 0
    end
    boxTable.box.Visible = true

    boxTable.name.Position = Vector2.new(pos.X, pos.Y - height / 2 - 18)
    boxTable.name.Text = character.Name
    boxTable.name.Color = RainbowName and getRainbowColor(5) or Color3.fromRGB(255, 255, 255)
    boxTable.name.Visible = true

    boxTable.healthText.Position = Vector2.new(pos.X, pos.Y + height / 2 + 2)
    boxTable.healthText.Text = ("HP: %d"):format(math.floor(humanoid.Health))
    boxTable.healthText.Color = RainbowHealth and getRainbowColor(4) or baseColor
    boxTable.healthText.Visible = true

    local dist = (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) and
        (player.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude or 0
    boxTable.distanceText.Position = Vector2.new(pos.X, pos.Y + height / 2 + 18)
    boxTable.distanceText.Text = ("%.1f studs"):format(dist)
    boxTable.distanceText.Color = Color3.fromRGB(200, 200, 200)
    boxTable.distanceText.Visible = true

    return true
end

local function espLoop(deltaTime)
    for ply, boxTable in pairs(boxes) do
        local character = ply.Character
        if character and character.Parent then
            local alive = updateBox(boxTable, character, deltaTime)
            if not alive then
                removeBox(boxTable)
                boxes[ply] = nil
            end
        else
            removeBox(boxTable)
            boxes[ply] = nil
        end
    end
end

local function addPlayer(ply)
    if ply == player then return end
    if boxes[ply] then return end

    local function onCharacterAdded(character)
        if not espEnabled then return end
        if boxes[ply] then return end
        boxes[ply] = createBox()
    end

    ply.CharacterAdded:Connect(onCharacterAdded)

    if ply.Character then
        boxes[ply] = createBox()
    end
end

local function removePlayer(ply)
    if boxes[ply] then
        removeBox(boxes[ply])
        boxes[ply] = nil
    end
end

local espLastTime = tick()

local function toggleESP(state)
    espEnabled = state

    if not espEnabled then
        for ply, boxTable in pairs(boxes) do
            removeBox(boxTable)
        end
        boxes = {}
    else
        for _, ply in pairs(Players:GetPlayers()) do
            addPlayer(ply)
        end
    end
end

Players.PlayerAdded:Connect(addPlayer)
Players.PlayerRemoving:Connect(removePlayer)

RunService.RenderStepped:Connect(function()
    if espEnabled then
        local now = tick()
        local deltaTime = now - espLastTime
        espLastTime = now
        espLoop(deltaTime)
    end
end)

sectionESP:AddToggle({
    Name = "Enable ESP",
    Default = false,
    Callback = function(v)
        toggleESP(v)
    end
})

sectionESP:AddToggle({
    Name = "Rainbow Name",
    Default = false,
    Callback = function(v)
        RainbowName = v
    end
})

sectionESP:AddToggle({
    Name = "Rainbow Health",
    Default = false,
    Callback = function(v)
        RainbowHealth = v
    end
})

sectionESP:AddToggle({
    Name = "Rainbow Box",
    Default = false,
    Callback = function(v)
        RainbowBox = v
    end
})

----------------- ABA AIM -----------------
local tabAim = UI:DrawTab({Name = "AIM", Icon = "star"})
local sectionAim = tabAim:DrawSection({Name = "Aim Menu", Position = "left"})

local aimbotEnabled = false
local fov = 100

local FOVring = Drawing.new("Circle")
FOVring.Visible = false
FOVring.Thickness = 2
FOVring.Color = Color3.fromRGB(128, 0, 128) -- Roxo
FOVring.Filled = false
FOVring.Radius = fov
FOVring.Position = Camera.ViewportSize / 2

local function updateDrawings()
    local camViewportSize = Camera.ViewportSize
    FOVring.Position = camViewportSize / 2
end

local function lookAt(target)
    local lookVector = (target - Camera.CFrame.Position).unit
    local newCFrame = CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + lookVector)
    Camera.CFrame = newCFrame
end

local function isEnemy(player1, player2)
    if not player1.Team or not player2.Team then
        return false
    end
    return player1.Team ~= player2.Team
end

local function getClosestPlayerInFOV(trg_part)
    local nearest = nil
    local last = math.huge
    local playerMousePos = Camera.ViewportSize / 2
    local localPlayer = Players.LocalPlayer

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild(trg_part) then
            if isEnemy(localPlayer, plr) then
                local part = plr.Character[trg_part]
                local ePos, isVisible = Camera:WorldToViewportPoint(part.Position)
                local distance = (Vector2.new(ePos.X, ePos.Y) - playerMousePos).Magnitude

                if distance < last and isVisible and distance < fov then
                    last = distance
                    nearest = plr
                end
            end
        end
    end

    return nearest
end

RunService.RenderStepped:Connect(function()
    updateDrawings()
    if aimbotEnabled then
        local closest = getClosestPlayerInFOV("Head")
        if closest and closest.Character and closest.Character:FindFirstChild("Head") then
            lookAt(closest.Character.Head.Position)
        end
    end
    FOVring.Visible = aimbotEnabled
end)

sectionAim:AddToggle({
    Name = "Activate Aimbot",
    Default = false,
    Callback = function(v)
        aimbotEnabled = v
    end
})

sectionAim:AddSlider({
    Name = "FOV Size",
    Min = 50,
    Max = 300,
    Default = 100,
    Callback = function(v)
        fov = v
        FOVring.Radius = v
    end
})

----------------- ABA MAIN -----------------
local tabMain = UI:DrawTab({Name = "Main", Icon = "tag"})
local sectionMain = tabMain:DrawSection({Name = "Cheats", Position = "left"})

local RemoteClaim = ReplicatedStorage:WaitForChild("Network"):WaitForChild("SessionLengthIncentive/ClaimReward")
local RemoteConsume = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Consumables/Consume")

local enabledAutoClaim = false
local selectedTroll = "Speed"

sectionMain:AddToggle({
    Name = "Auto Claim Bonus",
    Default = false,
    Callback = function(v)
        enabledAutoClaim = v
        if v then
            RemoteClaim:FireServer()
        end
    end
})

sectionMain:AddDropdown({
    Name = "Choose Troll",
    List = {"Speed", "BearTrap", "FreezeAllSeekers", "InvisibleWhileMoving"},
    Value = "Speed",
    Callback = function(choice)
        selectedTroll = choice
        RemoteConsume:FireServer(choice)
    end
})

local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local isNoclipEnabled = false
local isInfiniteJumpEnabled = false

sectionMain:AddToggle({
    Name = "Noclip",
    Default = false,
    Callback = function(v)
        isNoclipEnabled = v
        if not v and player.Character then
            for _, part in pairs(player.Character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
})

sectionMain:AddToggle({
    Name = "Infinite Jump",
    Default = false,
    Callback = function(v)
        isInfiniteJumpEnabled = v
    end
})

UserInputService.JumpRequest:Connect(function()
    if isInfiniteJumpEnabled and humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

RunService.Stepped:Connect(function()
    if isNoclipEnabled and player.Character then
        for _, part in pairs(player.Character:GetChildren()) do
            if part:IsA("BasePart") and part.CanCollide then
                part.CanCollide = false
            end
        end
    end
end)

----------------- ABA EXTRA -----------------
local tabExtra = UI:DrawTab({Name = "Extra", Icon = "settings"})
local sectionExtra = tabExtra:DrawSection({Name = "Misc", Position = "left"})

-- Invisible toggle
sectionExtra:AddToggle({
    Name = "Invisible",
    Default = false,
    Callback = function(value)
        if value then
            loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-FELIPEHUB-INVISIBLE-BYPASS-33793"))()
        end
    end
})

-- Speed slider (max 100)
local speedValue = 16
local maxSpeed = 100
local humanoid = nil
local char = player.Character or player.CharacterAdded:Wait()
humanoid = char:WaitForChild("Humanoid")

sectionExtra:AddSlider({
    Name = "Speed",
    Min = 16,
    Max = maxSpeed,
    Default = 16,
    Callback = function(v)
        speedValue = v
        if humanoid then
            humanoid.WalkSpeed = speedValue
        end
    end
})

-- Hitbox toggle and size slider (não ativa em você)
local hitboxEnabled = false
local hitboxSize = Vector3.new(2, 2, 1)

sectionExtra:AddToggle({
    Name = "Hitbox",
    Default = false,
    Callback = function(v)
        hitboxEnabled = v
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= player and plr.Character then
                local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    if hitboxEnabled then
                        hrp.Size = hitboxSize
                        hrp.Transparency = 0.5
                    else
                        hrp.Size = Vector3.new(2, 2, 1)
                        hrp.Transparency = 1
                    end
                end
            end
        end
    end
})

sectionExtra:AddSlider({
    Name = "Hitbox Size",
    Min = 1,
    Max = 10,
    Default = 2,
    Callback = function(v)
        hitboxSize = Vector3.new(v, v, 1)
        if hitboxEnabled then
            for _, plr in pairs(Players:GetPlayers()) do
                if plr ~= player and plr.Character then
                    local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.Size = hitboxSize
                    end
                end
            end
        end
    end
})

-- Plataforma e teleporte distante
local platformPart = nil
sectionExtra:AddButton({
    Name = "Create Platform + Teleport",
    Callback = function()
        if platformPart then
            platformPart:Destroy()
            platformPart = nil
        end
        platformPart = Instance.new("Part")
        platformPart.Size = Vector3.new(50, 1, 50)
        platformPart.Anchored = true
        platformPart.Position = Vector3.new(0, 1000, 0)
        platformPart.Transparency = 0.5
        platformPart.Parent = Workspace

        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = CFrame.new(0, 1005, 0)
        end
    end
})

UI:Init()
